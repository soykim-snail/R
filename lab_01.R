<<<<<<< HEAD
#문제1
#1부터 10사이의 벡터를 만들어서 v1 이라는 변수에 저장한다.
#각 원소 값들에 2를 곱한 결과로 벡터 v2 를 만든다.
#v2 에서 최대값을 추출하여 max_v 에 저장한다.
#v2 에서 최소값을 추출하여 min_v 에 저장한다.
#v2 에서 평균값을 추출하여 avg_v 에 저장한다.
#v2 에서 합을 추출하여 sum_v 에 저장한다.
#v2 에서 5번째 원소를 제외하고 v3 라는 변수에 저장한다.
#v1, v2, v3, max_v, min_v, avg_v, sum_v를 화면에 출력한다.
v1 <- c(1:10)
v2 <-v1 *2
max_v <- max(v2)
min_v <- min(v2)
avg_v <- mean(v2)
sum_v <- sum(v2)
v3 <- v2[-5]
ls()

#문제2
# seq() 또는 rep() 함수를 이용하여 다음과 같이 구성되는 벡터를 생성하여 각각 v4, v5, v6, v7 에 저장한 후에 출력한다.
# (1) 1, 3, 5, 7, 9
# (2) 1, 1, 1, 1, 1
# (3) 1, 2, 3, 1, 2, 3, 1, 2, 3
# (4) 1, 1, 2, 2, 3, 3, 4, 4
v5 <- seq(1, 9, 2)
v6 <- rep(1, 5)
v7 <- rep(1:3, times=3)
v8 <- rep(1:4, each=2)
v5;v6;v7;v8

#문제3
# 1부터 100으로 구성되는 10개의 중복되지 않는 데이터를 추출하여 nums 라는 백터를 만든다. 
# 오름차순으로 정렬한 결과를 출력한다.
# 내림차순으로 정렬한 결과를 출력한다.
# 50보다 큰 원소 값들만 출력한다.
# 50보다 작거나 같은 원소들의 인덱스를 출력한다.
# 최대값을 저장하고 있는 원소의 인덱스를 출력한다.
# 최소값을 저장하고 있는 원소의 인덱스를 출력한다.
num <- sample(1:100, 10, replace=F)
sort(num)
sort(num, decreasing = T)
num[num > 50]
which(num<=50)
which.max(num)
which.min(num)

#문제4
# 1부터 10 까지 출력하는데 
# 3씩 증가 되는 형태로(1 4 7 10)저장되는 벡터를 
# 정의하여 v8 변수에 저장한 다음 
# R 의 내장 백터를 활용하여 
# v8의 각 원소에 "A", "B", "C", D" 라는 이름을 부여한다.
v8 <- seq(1, 10, by=3)
names(v8) <- LETTERS[1:4]

#문제5
# 1부터 20으로 구성되는 5개의 중복되지 않는 데이터를 추출하여 
# score 라는 백터를 만든다. 
# myFriend 이라는 이름으로 
# “둘리”, “또치”, “도우너”, “희동”, “듀크” 값으로 벡터를 만든다. 
# 
# (1) 다음 형식으로 구성되는 벡터를 생성하여 출력한다.
# 추출된 값이 – 15, 7, 3, 9, 10 이라면 다음과 같이 출력한다.
# “15-둘리” “7-또치” “3-도우너” “9-희동” “10-듀크”
# (2) 점수가 가장 높은 친구의 이름을 출력한다.
# (3) 점수가 가장 낮은 친구의 이름을 출력한다.
# (4) 점수가 10점보다 높은 친구의 이름들을 출력한다.
score <- sample(1:20, 5, replace=F)
myFriend <- c("둘리", "또치", "도우너", "희동", "듀크")
paste(score, myFriend, sep="-") #paste0(score, myFriend)
myFriend[which.max(score)]
myFriend[which.min(score)]
myFriend[score>10]
=======
#문제1
#1부터 10사이의 벡터를 만들어서 v1 이라는 변수에 저장한다.
#각 원소 값들에 2를 곱한 결과로 벡터 v2 를 만든다.
#v2 에서 최대값을 추출하여 max_v 에 저장한다.
#v2 에서 최소값을 추출하여 min_v 에 저장한다.
#v2 에서 평균값을 추출하여 avg_v 에 저장한다.
#v2 에서 합을 추출하여 sum_v 에 저장한다.
#v2 에서 5번째 원소를 제외하고 v3 라는 변수에 저장한다.
#v1, v2, v3, max_v, min_v, avg_v, sum_v를 화면에 출력한다.
v1 <- c(1:10)
v2 <-v1 *2
max_v <- max(v2)
min_v <- min(v2)
avg_v <- mean(v2)
sum_v <- sum(v2)
v3 <- v2[-5]
ls()

#문제2
# seq() 또는 rep() 함수를 이용하여 다음과 같이 구성되는 벡터를 생성하여 각각 v4, v5, v6, v7 에 저장한 후에 출력한다.
# (1) 1, 3, 5, 7, 9
# (2) 1, 1, 1, 1, 1
# (3) 1, 2, 3, 1, 2, 3, 1, 2, 3
# (4) 1, 1, 2, 2, 3, 3, 4, 4
v5 <- seq(1, 9, 2)
v6 <- rep(1, 5)
v7 <- rep(1:3, times=3)
v8 <- rep(1:4, each=2)
v5;v6;v7;v8

#문제3
# 1부터 100으로 구성되는 10개의 중복되지 않는 데이터를 추출하여 nums 라는 백터를 만든다. 
# 오름차순으로 정렬한 결과를 출력한다.
# 내림차순으로 정렬한 결과를 출력한다.
# 50보다 큰 원소 값들만 출력한다.
# 50보다 작거나 같은 원소들의 인덱스를 출력한다.
# 최대값을 저장하고 있는 원소의 인덱스를 출력한다.
# 최소값을 저장하고 있는 원소의 인덱스를 출력한다.
num <- sample(1:100, 10, replace=F)
sort(num)
sort(num, decreasing = T)
num[num > 50]
which(num<=50)
which.max(num)
which.min(num)

#문제4
# 1부터 10 까지 출력하는데 
# 3씩 증가 되는 형태로(1 4 7 10)저장되는 벡터를 
# 정의하여 v8 변수에 저장한 다음 
# R 의 내장 백터를 활용하여 
# v8의 각 원소에 "A", "B", "C", D" 라는 이름을 부여한다.
v8 <- seq(1, 10, by=3)
names(v8) <- LETTERS[1:4]

#문제5
# 1부터 20으로 구성되는 5개의 중복되지 않는 데이터를 추출하여 
# score 라는 백터를 만든다. 
# myFriend 이라는 이름으로 
# “둘리”, “또치”, “도우너”, “희동”, “듀크” 값으로 벡터를 만든다. 
# 
# (1) 다음 형식으로 구성되는 벡터를 생성하여 출력한다.
# 추출된 값이 – 15, 7, 3, 9, 10 이라면 다음과 같이 출력한다.
# “15-둘리” “7-또치” “3-도우너” “9-희동” “10-듀크”
# (2) 점수가 가장 높은 친구의 이름을 출력한다.
# (3) 점수가 가장 낮은 친구의 이름을 출력한다.
# (4) 점수가 10점보다 높은 친구의 이름들을 출력한다.
score <- sample(1:20, 5, replace=F)
myFriend <- c("둘리", "또치", "도우너", "희동", "듀크")
paste(score, myFriend, sep="-")
myFriend[which.max(score)]
myFriend[which.min(score)]
myFriend[score>10]
>>>>>>> 83a4c1eb836ce28bb7864c0f5520b57534ac1e76
